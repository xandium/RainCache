<h1 id="raincache">RainCache</h1>
<hr />
<h2 id="a-simple-and-modular-discord-caching-library">A simple and modular discord caching library</h2>
<p>Part of the WeatherStack</p>
<p>You want to use a shared cache for your discord bot ? Maybe MongoDB ? But Presences should be stored in redis ?</p>
<p>Then RainCache is the right tool for the job!</p>
<h4 id="cool-things-you-can-do-with-raincache-">Cool things you can do with RainCache:</h4>
<ul>
<li>Store data received from discord in a configurable storage medium</li>
<li>Select the type of storage on a type level basis (e.g Channel, Presence, etc..)</li>
<li>Batteries included, RainCache can parse raw discord events and store the data accordingly</li>
<li>Easily customizable, you can write your own storage engine, connector or cache class</li>
</ul>
<h4 id="documentation-">Documentation:</h4>
<p>You can find the docs at <a href="https://daswolke.github.io/RainCache/">https://daswolke.github.io/RainCache/</a></p>
<h4 id="installation-">Installation:</h4>
<p>To install RainCache, make sure that you have node 8 or higher and npm installed on your computer.<br>Then run the following command in a terminal <code>npm install raincache</code></p>
<h4 id="example-">Example:</h4>
<pre><code class="lang-js">let RainCache = require(&#39;raincache&#39;);
// Load the Amqp Connector
let AmqpConnector = RainCache.Connectors.AmqpConnector; 
// Load the redis storage engine class
let RedisStorageEngine = RainCache.Engines.RedisStorageEngine; 
// Use the default options and create a new connector which isn&#39;t connected yet
let con = new AmqpConnector(); 
// Create a new uninitialized RainCache instance, set redis as the default storage engine, 
// disable debugging mode and pass an inbound and an outbound connector to receive and forward events
let cache = new RainCache({
    storage: {
        default: new RedisStorageEngine({
            host: &#39;localhost&#39;
        })
    }, debug: false}, 
    con, con);

let init = async () =&gt; {
    // initialize the cache, the connector and the database connection
    await cache.initialize(); 
};
// Declare an asynchronous init method
init().then(() =&gt; {
    console.log(&#39;Cache initialized&#39;);
}).catch(e =&gt; console.error(e));
// Run the init function
</code></pre>
<h4 id="small-tricks-and-hints-">Small tricks and hints:</h4>
<ul>
<li>RainCache creates an entry on the user collection with an id of &quot;self&quot; when it processes the READY packet,<br>this entry only contains an id and allows you to easily get the current user from the cache by looking up the id.</li>
</ul>
<hr>
<h4 id="notable-difference-to-normal-caches">Notable Difference to normal caches</h4>
<p>RainCache generally does not have any differences in comparison with general discord library caches, but there is one notable difference: </p>
<p><strong>Presences are stored per user and not per guild</strong></p>
<p>This means that you should make sure to fetch all users of a guild on startup of the gateway (by using guild member chunk),<br>because you may have to deal with users that are not cached yet.<br>This decision has the benefit,that you can safely ignore the presence_update event when you do not care about the status (online/offline, etc..) of a user.<br>Apart from that it allows RainCache to minimize the storage usage a lot, since a user has one presence instead of x presences.</p>
<hr>
<h4 id="object-binding">Object Binding</h4>
<p>RainCache returns the data received as a cache object with additional properties found in the retrieved data.<br> This way you can easily retrieve additional properties of received data (e.g. permission overwrites of a channel).</p>
<pre><code class="lang-js">let cache = new RainCache(someOptions);
let channel = await cache.channel.get(&#39;channel id&#39;) 
// The received object is a channel cache with the properties of the retrieved channel object (id, name, type, etc..) attached to it
let overwrites = await channel.permissionOverwrites.getIndexMembers() 
//this would load all permission overwrites for the channel previously loaded
</code></pre>
<hr>
<h4 id="indexing">Indexing</h4>
<p>RainCache uses indexing to allow you to easily get something like a list of all members of a server or similar,<br>although, depending on the storage engine you use, it might not be needed.<br>Whether indexing is used is up to the programmer of the storage engine you use.<br>The Redis Storage Engine which is already shipped with RainCache does use indexing by creating a redis set per namespace with a collection of ids in it.<br>This way you have a redis set containing something like a list of all members that are in a server available at <code>guild.$guild_id.member</code></p>
